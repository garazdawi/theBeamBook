[[CH-Beam_loader]]
== The BEAM Loader

// Translation to internal format.
//   Optimizations.
//   Rewrites
//   Peephole optimisztions
//   pack engine?
//
// ops.tab format/syntax
//  Catches
// Linking and Exports

=== Transforming from Generic to Specific instructions

The BEAM loader does not just take the external beam format and writes
it to memory. It also does a number of transformations on the code
and translates from the external (generic) format to the internal
(specific) format.

The code for the loader can be found in +beam_load.c+ (in
+erts/emulator/+) but most of the logic for the translations are in
the file +ops.tab+ (in the same directory).

The first step of the loader is to parse beam file, basically the same
work as we did in Erlang in xref:CH-beam_modules[] but written in C.

Then the rules in ops.tab are applied to instructions in the code
chunk to translate the generic instruction to one or more specific
instructions.

The translation table works through pattern matching. Each line in the
file defines a pattern of one or more generic instructions with
arguments and optionally an arrow followed by one or more instructions
to translate to.

The transformations in ops tab tries to handle patterns of
instructions generated by the compiler and peephole optimize them to
fewer specific instructions. The ops tab transformations tries to
generate jump tables for patterns of selects.

The file ops.tab is not parsed at runtime, instead a pattern matching
program is generated from ops.tab and stored in an array in a
generated C file. The perl script +beam_makeops+ (in
+erts/emulator/utils+) generates a target specific set of opcodes and
translation programs in the files +beam_opcodes.h+ and
+beam_opcodes.c+ (these files end up in the given target directory
e.g. +erts/emulator/x86_64-unknown-linux-gnu/opt/smp/+).

The same program (beam_makeops) also generates the Erlang code for the
compiler back end +beam_opcodes.erl+.

=== Understanding ops.tab

// Missing description about build specific options, i.e. the %unless construct

The transformations in ops.tab are executed in the order that they are
written in the file. So just like in Erlang pattern matching, the different
rules are triggered from top to bottom.

The types that ops.tab uses for arguments in instructions can be found in
xref:AP-Instructions[].

==== Transformation

// This section should be expanded with explanations about
// what goes on when a more complex tranformation is done.
// for instance this select_val transform
//
// is_integer Fail=f S | select_val S=s Fail=f Size=u Rest=* | use_jump_tab(Size, Rest) => \
//  gen_jump_tab(S, Fail, Size, Rest)
//
// also bif specific transformations should be mentioned.

Most of the rules in ops.tab are transformations between different
instructions. A simple transformation looks like this:

....
move S x==0 | return => move_return S
....

This combines a `move` from any location to `x(0)` and return into a single
instruction called `move_return`. Let's break the tranformation apart to
see what the different parts do.

`move` is the instruction that the pattern first has to match. This can be either
an generic instruction that the compiler has emitted, or a temporary instruction
that ops.tab has emitted to help with transformations.

`S` is a variable binding any type of value. Any value in the pattern (left hand side or +=>+)
that is used in the generator (right hand side of +=>+) has to be bound to a variable.

`x==0` is a guard that says that we only apply the transformation if the target
location is an x register with the value 0. It is possible to chain multiple
types and also bind a variable here. For instance `D=xy==0` would allow both
x and y registers with a value of 0 and also bind the argument to the variable `D`.

`|` signifies the end of this instruction and the beginning of another instruction
that is part of the same pattern.

`return` is the second instruction to match in this pattern.

`+=>+` signifies the end of the pattern and the start of the code that is to be
generated.

`move_return S` is the name of the generated instruction together with the name of
the variable on the lhs. It is possible to generate multiple instructions as part of
a transformation by using the `|` symbol.

==== Specific instruction

// This section should be expanded to include description of all the different options
// that can be given to %macro, i.e. -pack, -fail_action, -gen_dest, -goto,

When all transformations are done, we have to decide how the specifc instruction should
look like. Let's continue to look at `move_return`:

....
%macro: move_return MoveReturn -nonext
move_return x
move_return c
move_return n
....

This will generate three different instructions that will use the `MoveReturn` macro in
beam_emu.c to do the work.

`%macro: move_return` this tells ops.tab to generate the code for `move_return`. If there
is no `%macro` line, the instruction has to be implemented by hand in beam_emu.c. The code
for the instruction will be places in `beam_hot.h` or `beam_cold.h` depending on if the
`%hot` or `%cold` directive is active.

`MoveReturn` tells the code generator to that the name of the c-macro in beam_emu.c to use
is MoveReturn. This macro has to be implemented manually.

`-nonext` tells the code generator that it should not generate a dispatch to the next
instruction, the `MoveReturn` macro will take care of that.

`move_return x` tells the code generator to generate a specific instruction for when the
instruction argument is an x register. `c` for when it is a constant, `n` when it is `NIL`.
No instructions are in this case generated for when the argument is a y register as the
compiler will never generate such code.

The resulting code in beam_hot.h will look like this:

....
OpCase(move_return_c):
    {
    MoveReturn(Arg(0));
    }

OpCase(move_return_n):
    {
    MoveReturn(NIL);
    }

OpCase(move_return_x):
    {
    MoveReturn(xb(Arg(0)));
    }
....

All the implementor has to do is to define the MoveReturn macro in beam_emu.c and the instruction
is complete.
